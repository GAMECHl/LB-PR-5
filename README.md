# LB-PR-5-Hurzidze-Anton

## Хурцидзе Антон IПЗ 4.02 Лабораторна-Практична робота № 5

## Тема: Обробка координатних даних: Придушення шумів у потоці (Real-time).
## Мета: Реалізувати програмну архітектуру для потокової (real-time) обробки координатних даних (імітація роботи мікроконтролера, без доступу до "майбутніх" точок). Імплементувати три типи цифрових фільтрів: SMA (Simple Moving Average), EMA (Exponential Moving Average) та Median Filter. Дослідити компроміс між якістю фільтрації (гладкістю) та динамічними спотвореннями (затримкою/lag). Провести спектральний аналіз помилки фільтрації.

### 1. Підготовка коду

#### Створюємо новий ноутбук в застосунку Google Colab та копіюємо код з завдання:

![0](https://github.com/GAMECHl/LB-PR-5/blob/main/0.png)
#### Рис. 1 - Створенний ноутбук

### 2. Реалізація

#### У блоці "2. РЕАЛІЗАЦІЯ ФІЛЬТРІВ" змінюємо TODO та return x на робочий кодта запускаємо скрипт. Лінії на графіках згладженні, тому все вірно:

`` class SMAFilter:
    def __init__(self, w):
        self.w = w
        self.q = deque(maxlen=w)
        self.sum = 0.0  # Для оптимізації O(1) ``
        
    def update(self, x):
        # Якщо черга повна, віднімаємо старий елемент
        if len(self.q) == self.w:
            self.sum -= self.q[0]
        
        # Додаємо новий елемент
        self.q.append(x)
        self.sum += x
        
        # Повертаємо середнє
        return self.sum / len(self.q) 

`` class EMAFilter:
    def __init__(self, alpha):
        self.a = alpha
        self.last = None ``

    def update(self, x):
        # Ініціалізація першим значенням
        if self.last is None:
            self.last = x
        else:
            # Експоненційне згладжування
            self.last = self.a * x + (1 - self.a) * self.last
        
        return self.last

`` class MedianFilter:
    def __init__(self, w):
        if w % 2 == 0:
            w += 1
        self.w = w
        self.q = deque(maxlen=w)``

    def update(self, x):
        # Додаємо елемент у чергу
        self.q.append(x)
        
        # Повертаємо медіану
        return np.median(self.q) 

### 2.1. Баланс

#### Встановлюємо наступні параметри: W_SMA = 20, A_EMA = 0.1, W_MED = 21. та запускаємо код:

![1](https://github.com/GAMECHl/LB-PR-5/blob/main/1.png)
#### Рис. 2 - Графік "Баланс"

#### На ділянці змійки (12-20 секунд) всі фільтри відстають від ідеальної траєкторії. SMA з вікном 20 точок створює затримку 0.4 секунди (20/50 = 0.4 с) та "зрізає кути" через усереднення. EMA з α=0.1 має еквівалентне вікно ~20 точок і поводиться схожим чином. Медіанний фільтр W=21 реагує трохи швидше на повороти, але має більше дрібних коливань через "стрибки" медіани між сусідніми значеннями.
#### Ключова перевага медіани: вона повністю ігнорує викиди — різкі піки на графіку 1 не впливають на зелену лінію. Натомість SMA розмазує кожен викид на 20 точок (0.4 с), створюючи хвилеподібні артефакти на синій лінії. Для GPS-даних з частими викидами це критична різниця.

### 2.2. Екстремальне згладжування

#### Далі змінюємо параметри на - W_SMA = 100 (2 секунди пам'яті), A_EMA = 0.02. та запускаємо код:

![2](https://github.com/GAMECHl/LB-PR-5/blob/main/2.png)
#### Рис. 3 - Графік "Екстремальне згладжування"

#### На спектрі 4b (графік помилки Y) видно парадокс згладжування: справа (високі частоти >5 Гц) кольорові лінії нижче сірої — шум добре придушений. Але зліва (низькі частоти 0.2-2 Гц) з'являється "горб" ВИЩЕ базового шуму. Це означає, що фільтр створює нову помилку, більшу за вхідний шум.
#### Пояснення резонансу: Змійка має період 2 с (частота 0.5 Гц). SMA з вікном 100 точок усереднює рівно за 2 секунди (100/50 = 2 с). Фільтр запізнюється на 1 секунду (половину вікна) і створює систематичну помилку 3-5 метрів замість 0.8 м початкового шуму. На графіку 2 це видно на ділянці 10-13 с: синя та помаранчева лінії значно відстають від чорної пунктирної при різких змінах напрямку.
#### Висновок: Надмірне згладжування (вікно ≥ періоду сигналу) шкодить більше, ніж допомагає — фільтр втрачає саму траєкторію, а не лише шум.

### 2.3. Медіанний фільтр

#### Далі змінюємо параметри на - W_MED = 5(всі інші базові) та запускаємо код:

![3](https://github.com/GAMECHl/LB-PR-5/blob/main/3.png)
#### Рис. 4 - Графік "Медіанний фільтр"

#### Медіана з маленьким вікном (5 точок = 0.1 секунди) швидше реагує на зміни траєкторії — затримка скорочується до 0.05 с (половина вікна). Фільтр стає більш "чутливим" і може пропустити викиди, якщо вони тривають ≥3 точки підряд (медіана завжди вибирає середнє значення з відсортованого списку, тому потрібно мінімум 3 нормальні точки з 5).
#### Порівняння з SMA: За гладкістю медіана W=5 схожа на SMA W=3-4, але значно краще фільтрує поодинокі викиди. Навіть якщо викид триває 2 точки, медіана залишає 3 нормальні точки в вікні, тоді як SMA розподілить аномалію на всі 5 точок.
#### На графіках 2 і 3 видно, що всі лінії в експерименті 3 дуже близькі до ідеалу — малі вікна дозволяють фільтрам швидко адаптуватися до змін, але ціна цього — менше придушення високочастотного шуму (спектр 4a/4b: зелена лінія вище на частотах >10 Гц).

### Висновок: 
#### (а) Видалення збоїв сенсора (викидів): Медіанний фільтр — безумовний лідер. Він повністю ігнорує поодинокі викиди, оскільки завжди вибирає середнє значення з відсортованого вікна. SMA та EMA розмазують кожен викид на всю довжину вікна, створюючи хвилеподібні артефакти.
#### (б) Плавне ведення траєкторії:SMA або EMA — краще справляються з цим завданням. Вони створюють ідеально гладку лінію без дрібних коливань. Медіана може "стрибати" між сусідніми значеннями, особливо при малих вікнах, що дає менш плавний результат.
#### Рекомендація для GPS-навігації: Використовувати медіану W=11-21 (0.2-0.4 с) для робастності до викидів, потім застосувати легкий SMA W=3-5 для фінального згладжування траєкторії. Це дає найкращий баланс: стійкість до аномалій + плавність руху.
